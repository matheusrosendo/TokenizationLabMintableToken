{"version":3,"sources":["getWeb3.js","App.js","serviceWorker.js","index.js"],"names":["getWeb3","Promise","resolve","reject","window","addEventListener","ethereum","web3","Web3","enable","console","log","provider","providers","HttpProvider","on","accounts","location","reload","App","props","state","loaded","contractOwner","whitelisted","kycAddress","ethAmountToBuyToken","ethAccountAmmount","cappuAccountAmmount","isToWhitelist","errorMessage","mochaTotalSupply","wrongNetworkError","labels","title","title2","subtitleOwner","subtitleWhitelisted","subtitleNotWhitelisted","PK","componentDidMount","eth","getAccounts","net","getId","networkId","instanceMyMintableToken","Contract","MyMintableToken","abi","networks","address","instanceMyMintableTokenSale","MyMintableTokenSale","instanceKycContract","KycContract","methods","owner","call","kycWhitelisted","isWhitelisted","updateUserTokens","listenToTokenTransfer","setState","whitelistAddress","alert","message","handleError","handleInputChange","event","target","value","type","checked","name","handleBuyToken","self","sendTransaction","from","to","_address","hash","document","getElementById","innerHTML","receipt","blockHash","receiptTrans","confirmationNumber","this","error","JSON","parse","slice","length","data","handleKycWhiteListing","setKycWhitelisted","send","setKycRevoked","_errorMessage","addTokenToMetamask","symbol","decimals","request","method","params","options","image","tokenAdded","balanceOf","inMochaAccountAmmount","utils","getBalance","inEthAccountAmmount","fromWei","totalSupply","inMochaTotalSupply","inEthAccountAmmountInString","substring","events","Transfer","reactInstance","className","id","placeholder","onChange","for","onClick","Component","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3337fbd8.chunk.js","sourcesContent":["import Web3 from \"web3\";\r\n\r\nconst getWeb3 = () =>\r\n  new Promise((resolve, reject) => {\r\n    // Wait for loading completion to avoid race conditions with web3 injection timing.\r\n    window.addEventListener(\"load\", async () => {\r\n      // Modern dapp browsers...\r\n      if (window.ethereum) {\r\n        const web3 = new Web3(window.ethereum);\r\n        try {\r\n          // Request account access if needed\r\n          await window.ethereum.enable();\r\n          // Accounts now exposed\r\n          resolve(web3);\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      }\r\n      // Legacy dapp browsers...\r\n      else if (window.web3) {\r\n        // Use Mist/MetaMask's provider.\r\n        const web3 = window.web3;\r\n        console.log(\"Injected web3 detected.\");\r\n        resolve(web3);\r\n      }\r\n      // Fallback to localhost; use dev console port by default...\r\n      else {\r\n        const provider = new Web3.providers.HttpProvider(\r\n          \"http://127.0.0.1:8545\"\r\n        );\r\n        const web3 = new Web3(provider);\r\n        console.log(\"No web3 instance injected, using Local web3.\");\r\n        resolve(web3);\r\n      }\r\n    });\r\n\r\n    //refresh page if account is changed\r\n    window.ethereum.on('accountsChanged', function (accounts) {\r\n      window.location.reload();\r\n    })\r\n    \r\n    //refresh page if chain is changed\r\n    window.ethereum.on('chainChanged', () => {\r\n      window.location.reload();\r\n    })\r\n  });\r\n\r\nexport default getWeb3;\r\n","import React, { Component } from \"react\";\r\nimport MyMintableToken from \"./contracts/MyMintableToken.json\";\r\nimport MyMintableTokenSale from \"./contracts/MyMintableTokenSale.json\";\r\nimport KycContract from \"./contracts/KycContract.json\";\r\nimport getWeb3 from \"./getWeb3\";\r\n\r\nimport \"./App.css\";\r\n\r\nclass App extends Component {\r\n  state = { loaded: false, contractOwner: false, whitelisted: false, kycAddress:\"\", ethAmountToBuyToken:1000, ethAccountAmmount:0, cappuAccountAmmount:0, isToWhitelist: \"allow\", errorMessage: \"\", mochaTotalSupply: 0, wrongNetworkError:\"Loading Web3, accounts, and contract...\"};\r\n  labels = {\r\n    title:\"StarDucks Mochacino IDO\", \r\n    title2:\"A Mintable Token Example\", \r\n    subtitleOwner:\"Welcome manager! This is your Kyc Whitelisting page.\", \r\n    subtitleWhitelisted:\"You are whitelisted!\", \r\n    subtitleNotWhitelisted:\"Sorry, you are not whitelisted!\",\r\n    PK:\"f3ce236978501cac7bca07ab5cf7700899eb3e2435c6d94e0d3bd346355f53f3\"\r\n  }\r\n\r\n  //put the instance in a window to be acessed externaly\r\n  constructor(props) {\r\n      super(props);\r\n      window.reactInstance = this;\r\n  }\r\n\r\n  componentDidMount = async () => {\r\n    try {\r\n      // Get network provider and web3 instance.\r\n      this.web3 = await getWeb3();\r\n\r\n      // Use web3 to get the user's accounts.\r\n      this.accounts = await this.web3.eth.getAccounts();\r\n\r\n      // Get the network data\r\n      this.networkId = await this.web3.eth.net.getId();\r\n      \r\n      //get the contract instances\r\n      this.instanceMyMintableToken = new this.web3.eth.Contract(\r\n        MyMintableToken.abi,\r\n        MyMintableToken.networks[this.networkId] && MyMintableToken.networks[this.networkId].address,\r\n      );\r\n\r\n      this.instanceMyMintableTokenSale = new this.web3.eth.Contract(\r\n        MyMintableTokenSale.abi,\r\n        MyMintableTokenSale.networks[this.networkId] && MyMintableTokenSale.networks[this.networkId].address,\r\n      );\r\n      \r\n      \r\n      this.instanceKycContract = new this.web3.eth.Contract(\r\n        KycContract.abi,\r\n        KycContract.networks[this.networkId] && KycContract.networks[this.networkId].address,\r\n      );\r\n\r\n      //get the owner of the contract\r\n      let owner = await this.instanceKycContract.methods.owner().call();\r\n      \r\n      //verify if current address is whitelisted\r\n      this.isWhitelisted = await this.instanceKycContract.methods.kycWhitelisted(this.accounts[0]).call();\r\n      \r\n      //get the balances on loading page\r\n      await this.updateUserTokens();\r\n\r\n      //refresh balances every event Transfer\r\n      await this.listenToTokenTransfer();\r\n      this.setState({ loaded: true, contractOwner: owner===this.accounts[0], whitelisted: this.isWhitelisted, whitelistAddress: true, errorMessage:\"\" });\r\n     \r\n    } catch (error) {\r\n      alert(\r\n        'Failed to load web3, accounts, or contract. Check console for details. Error: '+error.message\r\n      );\r\n      this.handleError(error);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handle form inputs on change\r\n   * @param {*} event \r\n   */\r\n\r\n  handleInputChange = (event) => {\r\n     const target = event.target;\r\n     const value = target.type === \"checkbox\" ? target.checked : target.value;\r\n     const name = target.name;\r\n     this.setState({[name]: value});\r\n  }\r\n \r\n  /**\r\n   * handle buy token function\r\n   */\r\n handleBuyToken = async () => {\r\n    //in order to get global access inside the callback function \r\n    let self = this;\r\n    await this.web3.eth.sendTransaction({from:this.accounts[0], to:this.instanceMyMintableTokenSale._address, value:this.state.ethAmountToBuyToken})\r\n    .on('transactionHash', function(hash){\r\n      document.getElementById(\"transactionHash\").innerHTML = hash;\r\n    })\r\n    .on('receipt', function(receipt){\r\n      document.getElementById(\"receipt\").innerHTML = receipt.blockHash;\r\n      window.receiptTrans = receipt;\r\n    })\r\n    .on('confirmation', async function(confirmationNumber, receipt){\r\n      document.getElementById(\"confirmation\").innerHTML = \"Number of confirmations: \"+confirmationNumber;\r\n      document.getElementById(\"infoMessage\").innerHTML = self.state.kycAddress+ \" Tokens bought successfully\";\r\n    })\r\n    .on('error', function(error, receipt) {\r\n      \r\n      let errorMessage = \"\";\r\n      try {\r\n        //slice returned error to get only message inside\r\n        errorMessage = JSON.parse(error.message.slice(58, error.message.length-2)).data.message;\r\n      } catch (error) {\r\n        errorMessage = error.message;\r\n      }\r\n      self.handleError({errorMessage: errorMessage});\r\n      \r\n    });\r\n  }\r\n\r\n  /**\r\n   * Whitelist handler: allow a given address to buy tokens (Owner only)\r\n   */\r\n  handleKycWhiteListing = async () => {\r\n    //in order to get global access inside the callback function \r\n    let self = this;\r\n    try {\r\n              \r\n      if(this.state.isToWhitelist === \"allow\"){\r\n        //self.inAddressArray = this.state.kycAddresses.split(\",\");\r\n        await this.instanceKycContract.methods.setKycWhitelisted(this.state.kycAddress).send({from: this.accounts[0]})\r\n        .on('transactionHash', function(hash){\r\n          document.getElementById(\"transactionHash\").innerHTML = hash;\r\n        })\r\n        .on('receipt', function(receipt){\r\n          document.getElementById(\"receipt\").innerHTML = receipt.blockHash;\r\n        })\r\n        .on('confirmation', function(confirmationNumber, receipt){\r\n          document.getElementById(\"confirmation\").innerHTML = \"Number of confirmations: \"+confirmationNumber;\r\n          document.getElementById(\"infoMessage\").innerHTML =  self.state.kycAddress+ \" was whitelisted successfully\";\r\n        })\r\n        .on('error', function(error, receipt) {\r\n          //slice returned error to get only message inside\r\n          var errorMessage = JSON.parse(error.message.slice(58, error.message.length-2));\r\n          self.handleError(errorMessage.data.message);\r\n        });\r\n            \r\n      } else { //revoke address\r\n        await this.instanceKycContract.methods.setKycRevoked(this.state.kycAddress).send({from: this.accounts[0]})\r\n        .on('transactionHash', function(hash){\r\n          document.getElementById(\"transactionHash\").innerHTML = hash;\r\n        })\r\n        .on('receipt', function(receipt){\r\n          document.getElementById(\"receipt\").innerHTML = receipt.blockHash;\r\n        })\r\n        .on('confirmation', function(confirmationNumber, receipt){\r\n          document.getElementById(\"confirmation\").innerHTML = \"Number of confirmations\"+confirmationNumber;\r\n          document.getElementById(\"infoMessage\").innerHTML = self.state.kycAddress+ \" was revoked from whitelist\";\r\n        })\r\n        .on('error', function(error, receipt) {\r\n          //slice returned error to get only message inside\r\n          var errorMessage = JSON.parse(error.message.slice(58, error.message.length-2));\r\n          self.handleError(errorMessage.data.message);\r\n        });        \r\n        \r\n      };\r\n    } catch (error) {\r\n        this.handleError(error);\r\n    }\r\n  }\r\n\r\n/**\r\n * Generic display of errors\r\n * @param {*} _errorMessage \r\n */\r\nhandleError = (_errorMessage) =>{\r\n  try {\r\n    document.getElementById(\"error\").innerHTML = _errorMessage;\r\n    this.setState({errorMessage: _errorMessage});\r\n  } catch (error) {\r\n    this.setState({errorMessage: error});\r\n  }  \r\n}\r\n\r\n/**\r\n * Button ADD Token to metamask handler\r\n */\r\naddTokenToMetamask = async () =>{\r\n    try {\r\n      const symbol = await this.instanceMyMintableToken.methods.symbol().call();\r\n      const decimals = await this.instanceMyMintableToken.methods.decimals().call();\r\n      console.log(\"decimals \"+decimals);\r\n      const tokenAdded = await window.ethereum.request({\r\n        method: 'wallet_watchAsset',\r\n        params: {\r\n          type: 'ERC20',\r\n          options: {\r\n            address: this.instanceMyMintableToken._address,\r\n            symbol: symbol,\r\n            decimals: decimals,\r\n            image: 'https://www.starbucksathome.com/pt/sites/default/files/2021-06/10032021_CafeMocha_CS-min.png'\r\n          }\r\n        }\r\n      });\r\n      if(tokenAdded){\r\n        document.getElementById(\"infoMessage\").innerHTML = symbol+ \" adicionado com sucesso\";\r\n      } else {\r\n        document.getElementById(\"infoMessage\").innerHTML = symbol+ \" nao foi possivel adicionar o token\";\r\n      }\r\n    } catch (error) {\r\n      this.handleError(error);\r\n    }\r\n }\r\n\r\n /**\r\n  * Refresh balances of ETH and MOCHA tokens and set to state\r\n  */\r\n updateUserTokens = async () => {\r\n  let inMochaAccountAmmount = await this.instanceMyMintableToken.methods.balanceOf(this.accounts[0]).call();\r\n  let inEthAccountAmmount = this.web3.utils.fromWei(await this.web3.eth.getBalance(this.accounts[0]), 'ether'); \r\n  let inMochaTotalSupply = await this.instanceMyMintableToken.methods.totalSupply().call();\r\n  let inEthAccountAmmountInString = \"0.0\";\r\n  if(inEthAccountAmmount > 0) {\r\n    inEthAccountAmmountInString = inEthAccountAmmount.substring(0,5);\r\n  }\r\n  this.setState({ ethAccountAmmount:inEthAccountAmmountInString, cappuAccountAmmount: inMochaAccountAmmount, mochaTotalSupply: inMochaTotalSupply});\r\n }\r\n\r\n\r\n /**\r\n  * Refresh balances every time event Transfer is listened sendind from or to the current address \r\n  */\r\n listenToTokenTransfer = async() => {\r\n   this.instanceMyMintableToken.events.Transfer({to: this.accounts[0]}).on(\"data\", this.updateUserTokens);\r\n   this.instanceMyMintableToken.events.Transfer({from: this.accounts[0]}).on(\"data\", this.updateUserTokens);\r\n }\r\n\r\n  render() {\r\n   \r\n    if (!this.state.loaded) {\r\n      return (\r\n        <div className=\"container\"> \r\n         <div className=\"form\">              \r\n            <div className=\"title2\">{this.state.wrongNetworkError}</div>\r\n        </div>\r\n       </div>\r\n      )\r\n    } else {\r\n      if(this.state.contractOwner){\r\n        return (\r\n          <div>\r\n           <div  className=\"plaintext\">connected account: {this.accounts[0]}  --- ETH: {this.state.ethAccountAmmount} / MOCHA: {this.state.cappuAccountAmmount} </div>\r\n            <div className=\"container\"> \r\n             \r\n              <div className=\"form\">              \r\n                <div className=\"title\">{this.labels.title}</div>\r\n                <div className=\"title2\">{this.labels.title2}</div>\r\n                <div className=\"subtitle\">{this.labels.subtitleOwner}</div>\r\n                <div className=\"input-container ic1\">\r\n                  <input id=\"allowAddress\"  type=\"radio\" placeholder=\" \" checked  name=\"isToWhitelist\" value=\"allow\" onChange={this.handleInputChange} />\r\n                  <label for=\"allowAddress\" className=\"radioLabel\">Allow Address</label>\r\n                </div>\r\n                <div className=\"input-container ic1\">\r\n                  <input id=\"revokeAddress\"  type=\"radio\" placeholder=\" \"  name=\"isToWhitelist\" value=\"revoke\" onChange={this.handleInputChange} />\r\n                  <label for=\"revokeAddress\" className=\"radioLabel\">Revoke Address</label>\r\n                </div>\r\n                <div className=\"input-container ic1\">\r\n                  <input id=\"firstname\" className=\"input\" type=\"text\" placeholder=\"\"  name=\"kycAddress\" value={this.state.kycAddress} onChange={this.handleInputChange} />\r\n                  <div className=\"cut\"></div>\r\n                  <label className=\"placeholder\">Address (0x123...)</label>\r\n                </div>\r\n                \r\n                <button type=\"button\" className=\"submit\" onClick={this.handleKycWhiteListing}>Update KYC Whitelist</button>\r\n              </div>\r\n               \r\n              <div className=\"warning\" id=\"infoMessage\"></div>\r\n              <div className=\"plaintext\" id=\"transactionHash\">transactionHash</div>\r\n              <div className=\"plaintext\" id=\"receipt\">Receipt</div>\r\n              <div className=\"plaintext\" id=\"confirmation\">Confirmations</div>\r\n              <div className=\"warning\" id=\"error\"></div>\r\n              \r\n            </div>\r\n          </div>\r\n        );\r\n      } else {\r\n        if(this.state.whitelisted){\r\n            return (\r\n              <div>\r\n                <div  className=\"plaintext\">connected account: {this.accounts[0]}  --- ETH: {this.state.ethAccountAmmount} / MOCHA: {this.state.cappuAccountAmmount} </div>\r\n                <div className=\"container\"> \r\n                  <div className=\"form2\">\r\n                    <div className=\"title\">{this.labels.title}</div>\r\n                    <div className=\"title2\">{this.labels.title2}</div>\r\n                    <div className=\"subtitle\">{this.labels.subtitleWhitelisted}</div>\r\n               \r\n                    <div className=\"input-container ic1\">\r\n                      <input id=\"firstname\" className=\"input\" type=\"text\" placeholder=\"\" name=\"ethAmountToBuyToken\" value={this.state.ethAmountToBuyToken} onChange={this.handleInputChange} />\r\n                      <div className=\"cut\"></div>\r\n                      <label className=\"placeholder\">ETH amount in wei</label>\r\n                    </div>                    \r\n                    <p>\r\n                      <button type=\"button\"  className=\"submit\" onClick={this.handleBuyToken}> Buy MOCHA Token</button>\r\n                      <button type=\"button\"  id=\"addToken\"  className=\"submit\" onClick={this.addTokenToMetamask}> Add MOCHA Token to metamask wallet</button>\r\n                    </p>                    \r\n                  </div>  \r\n                  <div className=\"warning\" id=\"infoMessage\"></div>\r\n                  <div className=\"plaintext\" id=\"transactionHash\">transactionHash</div>\r\n                  <div className=\"plaintext\" id=\"receipt\">Receipt</div>\r\n                  <div className=\"plaintext\" id=\"confirmation\">Confirmations</div>\r\n                  <div className=\"warning\" id=\"error\"></div>\r\n                </div>     \r\n              </div>\r\n            );\r\n        } else {\r\n          return (\r\n            <div>\r\n              <div  className=\"plaintext\">connected account: {this.accounts[0]}  --- ETH: {this.state.ethAccountAmmount} / MOCHA: {this.state.cappuAccountAmmount} </div>\r\n              <div className=\"container\"> \r\n                <div className=\"form2\">\r\n                <div className=\"title\">{this.labels.title}</div>\r\n                  <div className=\"title2\">{this.labels.title2}</div>\r\n                  <div className=\"subtitle\">{this.labels.subtitleNotWhitelisted}</div>\r\n                  <div className=\"title2\">To test this Dapp you should add the account used to deploy the Smart Contracts on your metamask, that is the PK: </div>\r\n                  <div className=\"subtitle\">{this.labels.PK}</div>\r\n                  <div className=\"disclaimer\">Disclaimer: this is an account with test and development purposes, never share your Private Keys!</div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          );\r\n        }\r\n      }\r\n    }\r\n    \r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}