{"version":3,"sources":["getWeb3.js","App.js","serviceWorker.js","index.js"],"names":["getWeb3","Promise","resolve","reject","window","addEventListener","ethereum","web3","Web3","enable","console","log","provider","providers","HttpProvider","on","accounts","location","reload","App","props","state","loaded","contractOwner","whitelisted","kycAddress","ethAmountToBuyToken","ethAccountAmmount","mochaAccountAmmount","isToWhitelist","errorMessage","mochaTotalSupply","wrongNetworkError","labels","title","title2","subtitleOwner","subtitleWhitelisted","subtitleNotWhitelisted","PK","componentDidMount","eth","getAccounts","net","getId","networkId","instanceMyMintableToken","Contract","MyMintableToken","abi","networks","address","instanceMyMintableTokenSale","MyMintableTokenSale","instanceKycContract","KycContract","methods","owner","call","kycWhitelisted","isWhitelisted","updateUserTokens","listenToTokenTransfer","setState","whitelistAddress","handleError","handleInputChange","event","target","value","type","checked","name","handleBuyToken","self","sendTransaction","from","to","_address","hash","document","getElementById","innerHTML","receipt","blockHash","receiptTrans","confirmationNumber","this","error","JSON","parse","message","slice","length","data","handleKycWhiteListing","setKycWhitelisted","send","setKycRevoked","_errorMessage","addTokenToMetamask","symbol","decimals","request","method","params","options","image","tokenAdded","balanceOf","inMochaAccountAmmount","utils","getBalance","inEthAccountAmmount","fromWei","totalSupply","inMochaTotalSupply","inEthAccountAmmountInString","substring","events","Transfer","reactInstance","className","id","placeholder","onChange","for","onClick","Component","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.0d3315f7.chunk.js","sourcesContent":["import Web3 from \"web3\";\r\n\r\nconst getWeb3 = () =>\r\n  new Promise((resolve, reject) => {\r\n    // Wait for loading completion to avoid race conditions with web3 injection timing.\r\n    window.addEventListener(\"load\", async () => {\r\n      // Modern dapp browsers...\r\n      if (window.ethereum) {\r\n        const web3 = new Web3(window.ethereum);\r\n        try {\r\n          // Request account access if needed\r\n          await window.ethereum.enable();\r\n          // Accounts now exposed\r\n          resolve(web3);\r\n        } catch (error) {\r\n          reject(error);\r\n        }\r\n      }\r\n      // Legacy dapp browsers...\r\n      else if (window.web3) {\r\n        // Use Mist/MetaMask's provider.\r\n        const web3 = window.web3;\r\n        console.log(\"Injected web3 detected.\");\r\n        resolve(web3);\r\n      }\r\n      // Fallback to localhost; use dev console port by default...\r\n      else {\r\n        const provider = new Web3.providers.HttpProvider(\r\n          \"http://127.0.0.1:8545\"\r\n        );\r\n        const web3 = new Web3(provider);\r\n        console.log(\"No web3 instance injected, using Local web3.\");\r\n        resolve(web3);\r\n      }\r\n    });\r\n\r\n    //refresh page if account is changed\r\n    window.ethereum.on('accountsChanged', function (accounts) {\r\n      window.location.reload();\r\n    })\r\n    \r\n    //refresh page if chain is changed\r\n    window.ethereum.on('chainChanged', () => {\r\n      window.location.reload();\r\n    })\r\n  });\r\n\r\nexport default getWeb3;\r\n","import React, { Component } from \"react\";\r\nimport MyMintableToken from \"./contracts/MyMintableToken.json\";\r\nimport MyMintableTokenSale from \"./contracts/MyMintableTokenSale.json\";\r\nimport KycContract from \"./contracts/KycContract.json\";\r\nimport getWeb3 from \"./getWeb3\";\r\n\r\nimport \"./App.css\";\r\n\r\nclass App extends Component {\r\n  state = { loaded: false, contractOwner: false, whitelisted: false, kycAddress:\"\", ethAmountToBuyToken:1000, ethAccountAmmount:0, mochaAccountAmmount:0, isToWhitelist: \"allow\", errorMessage: \"\", mochaTotalSupply: 0, wrongNetworkError:\"Loading Web3, accounts, and contract...\"};\r\n  labels = {\r\n    title:\"StarDucks Mochacino IDO\", \r\n    title2:\"A Mintable Token Example\", \r\n    subtitleOwner:\"Welcome manager! This is your Kyc Whitelisting page.\", \r\n    subtitleWhitelisted:\"You are whitelisted!\", \r\n    subtitleNotWhitelisted:\"Sorry, you are not whitelisted!\",\r\n    PK:\"f3ce236978501cac7bca07ab5cf7700899eb3e2435c6d94e0d3bd346355f53f3\"\r\n  }\r\n\r\n  //put the instance in a window to be acessed externaly\r\n  constructor(props) {\r\n      super(props);\r\n      window.reactInstance = this;\r\n  }\r\n\r\n  componentDidMount = async () => {\r\n    try {\r\n      // Get network provider and web3 instance.\r\n      this.web3 = await getWeb3();\r\n\r\n      // Use web3 to get the user's accounts.\r\n      this.accounts = await this.web3.eth.getAccounts();\r\n\r\n      // Get the network data\r\n      this.networkId = await this.web3.eth.net.getId();\r\n      \r\n      //get the contract instances\r\n      this.instanceMyMintableToken = new this.web3.eth.Contract(\r\n        MyMintableToken.abi,\r\n        MyMintableToken.networks[this.networkId] && MyMintableToken.networks[this.networkId].address,\r\n      );\r\n\r\n      this.instanceMyMintableTokenSale = new this.web3.eth.Contract(\r\n        MyMintableTokenSale.abi,\r\n        MyMintableTokenSale.networks[this.networkId] && MyMintableTokenSale.networks[this.networkId].address,\r\n      );\r\n      \r\n      \r\n      this.instanceKycContract = new this.web3.eth.Contract(\r\n        KycContract.abi,\r\n        KycContract.networks[this.networkId] && KycContract.networks[this.networkId].address,\r\n      );\r\n\r\n      //get the owner of the contract\r\n      let owner = await this.instanceKycContract.methods.owner().call();\r\n      \r\n      //verify if current address is whitelisted\r\n      this.isWhitelisted = await this.instanceKycContract.methods.kycWhitelisted(this.accounts[0]).call();\r\n      \r\n      //get the balances on loading page\r\n      await this.updateUserTokens();\r\n\r\n      //refresh balances every event Transfer\r\n      await this.listenToTokenTransfer();\r\n      this.setState({ loaded: true, contractOwner: owner===this.accounts[0], whitelisted: this.isWhitelisted, whitelistAddress: true, errorMessage:\"\" });\r\n     \r\n    } catch (error) {\r\n      this.handleError(error);\r\n      this.setState({wrongNetworkError: \"You need to connect your metamask wallet and choose the correct network: Ropsten, Goerli or Local Ganache\"});\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Handle form inputs on change\r\n   * @param {*} event \r\n   */\r\n\r\n  handleInputChange = (event) => {\r\n     const target = event.target;\r\n     const value = target.type === \"checkbox\" ? target.checked : target.value;\r\n     const name = target.name;\r\n     this.setState({[name]: value});\r\n  }\r\n \r\n  /**\r\n   * handle buy token function\r\n   */\r\n handleBuyToken = async () => {\r\n    //in order to get global access inside the callback function \r\n    let self = this;\r\n    await this.web3.eth.sendTransaction({from:this.accounts[0], to:this.instanceMyMintableTokenSale._address, value:this.state.ethAmountToBuyToken})\r\n    .on('transactionHash', function(hash){\r\n      document.getElementById(\"transactionHash\").innerHTML = hash;\r\n    })\r\n    .on('receipt', function(receipt){\r\n      document.getElementById(\"receipt\").innerHTML = receipt.blockHash;\r\n      window.receiptTrans = receipt;\r\n    })\r\n    .on('confirmation', async function(confirmationNumber, receipt){\r\n      document.getElementById(\"confirmation\").innerHTML = \"Number of confirmations: \"+confirmationNumber;\r\n      document.getElementById(\"infoMessage\").innerHTML = self.state.kycAddress+ \" Tokens bought successfully\";\r\n    })\r\n    .on('error', function(error, receipt) {\r\n      \r\n      let errorMessage = \"\";\r\n      try {\r\n        //slice returned error to get only message inside\r\n        errorMessage = JSON.parse(error.message.slice(58, error.message.length-2)).data.message;\r\n      } catch (error) {\r\n        errorMessage = error.message;\r\n      }\r\n      self.handleError({errorMessage: errorMessage});\r\n      \r\n    });\r\n  }\r\n\r\n  /**\r\n   * Whitelist handler: allow a given address to buy tokens (Owner only)\r\n   */\r\n  handleKycWhiteListing = async () => {\r\n    //in order to get global access inside the callback function \r\n    let self = this;\r\n    try {\r\n              \r\n      if(this.state.isToWhitelist === \"allow\"){\r\n        //self.inAddressArray = this.state.kycAddresses.split(\",\");\r\n        await this.instanceKycContract.methods.setKycWhitelisted(this.state.kycAddress).send({from: this.accounts[0]})\r\n        .on('transactionHash', function(hash){\r\n          document.getElementById(\"transactionHash\").innerHTML = hash;\r\n        })\r\n        .on('receipt', function(receipt){\r\n          document.getElementById(\"receipt\").innerHTML = receipt.blockHash;\r\n        })\r\n        .on('confirmation', function(confirmationNumber, receipt){\r\n          document.getElementById(\"confirmation\").innerHTML = \"Number of confirmations: \"+confirmationNumber;\r\n          document.getElementById(\"infoMessage\").innerHTML =  self.state.kycAddress+ \" was whitelisted successfully\";\r\n        })\r\n        .on('error', function(error, receipt) {\r\n          //slice returned error to get only message inside\r\n          var errorMessage = JSON.parse(error.message.slice(58, error.message.length-2));\r\n          self.handleError(errorMessage.data.message);\r\n        });\r\n            \r\n      } else { //revoke address\r\n        await this.instanceKycContract.methods.setKycRevoked(this.state.kycAddress).send({from: this.accounts[0]})\r\n        .on('transactionHash', function(hash){\r\n          document.getElementById(\"transactionHash\").innerHTML = hash;\r\n        })\r\n        .on('receipt', function(receipt){\r\n          document.getElementById(\"receipt\").innerHTML = receipt.blockHash;\r\n        })\r\n        .on('confirmation', function(confirmationNumber, receipt){\r\n          document.getElementById(\"confirmation\").innerHTML = \"Number of confirmations\"+confirmationNumber;\r\n          document.getElementById(\"infoMessage\").innerHTML = self.state.kycAddress+ \" was revoked from whitelist\";\r\n        })\r\n        .on('error', function(error, receipt) {\r\n          //slice returned error to get only message inside\r\n          var errorMessage = JSON.parse(error.message.slice(58, error.message.length-2));\r\n          self.handleError(errorMessage.data.message);\r\n        });        \r\n        \r\n      };\r\n    } catch (error) {\r\n        this.handleError(error);\r\n    }\r\n  }\r\n\r\n/**\r\n * Generic display of errors\r\n * @param {*} _errorMessage \r\n */\r\nhandleError = (_errorMessage) =>{\r\n  try {\r\n    document.getElementById(\"error\").innerHTML = _errorMessage;\r\n    this.setState({errorMessage: _errorMessage});\r\n  } catch (error) {\r\n    this.setState({errorMessage: error});\r\n  }  \r\n}\r\n\r\n/**\r\n * Button ADD Token to metamask handler\r\n */\r\naddTokenToMetamask = async () =>{\r\n    try {\r\n      const symbol = await this.instanceMyMintableToken.methods.symbol().call();\r\n      const decimals = await this.instanceMyMintableToken.methods.decimals().call();\r\n      console.log(\"decimals \"+decimals);\r\n      const tokenAdded = await window.ethereum.request({\r\n        method: 'wallet_watchAsset',\r\n        params: {\r\n          type: 'ERC20',\r\n          options: {\r\n            address: this.instanceMyMintableToken._address,\r\n            symbol: symbol,\r\n            decimals: decimals,\r\n            image: 'https://www.starbucksathome.com/pt/sites/default/files/2021-06/10032021_CafeMocha_CS-min.png'\r\n          }\r\n        }\r\n      });\r\n      if(tokenAdded){\r\n        document.getElementById(\"infoMessage\").innerHTML = symbol+ \" adicionado com sucesso\";\r\n      } else {\r\n        document.getElementById(\"infoMessage\").innerHTML = symbol+ \" nao foi possivel adicionar o token\";\r\n      }\r\n    } catch (error) {\r\n      this.handleError(error);\r\n    }\r\n }\r\n\r\n /**\r\n  * Refresh balances of ETH and MOCHA tokens and set to state\r\n  */\r\n updateUserTokens = async () => {\r\n  let inMochaAccountAmmount = await this.instanceMyMintableToken.methods.balanceOf(this.accounts[0]).call();\r\n  let inEthAccountAmmount = this.web3.utils.fromWei(await this.web3.eth.getBalance(this.accounts[0]), 'ether'); \r\n  let inMochaTotalSupply = await this.instanceMyMintableToken.methods.totalSupply().call();\r\n  let inEthAccountAmmountInString = \"0.0\";\r\n  if(inEthAccountAmmount > 0) {\r\n    inEthAccountAmmountInString = inEthAccountAmmount.substring(0,5);\r\n  }\r\n  this.setState({ ethAccountAmmount:inEthAccountAmmountInString, mochaAccountAmmount: inMochaAccountAmmount, mochaTotalSupply: inMochaTotalSupply});\r\n }\r\n\r\n\r\n /**\r\n  * Refresh balances every time event Transfer is listened sendind from or to the current address \r\n  */\r\n listenToTokenTransfer = async() => {\r\n   this.instanceMyMintableToken.events.Transfer({to: this.accounts[0]}).on(\"data\", this.updateUserTokens);\r\n   this.instanceMyMintableToken.events.Transfer({from: this.accounts[0]}).on(\"data\", this.updateUserTokens);\r\n }\r\n\r\n  render() {\r\n   \r\n    if (!this.state.loaded) {\r\n      return (\r\n        <div className=\"container\"> \r\n         <div className=\"form\">              \r\n            <div className=\"title2\">{this.state.wrongNetworkError}</div>\r\n        </div>\r\n       </div>\r\n      )\r\n    } else {\r\n      if(this.state.contractOwner){\r\n        return (\r\n          <div>\r\n           <div  className=\"plaintext\">connected account: {this.accounts[0]}  --- ETH: {this.state.ethAccountAmmount} / MOCHA: {this.state.mochaAccountAmmount} </div>\r\n            <div className=\"container\"> \r\n             \r\n              <div className=\"form\">              \r\n                <div className=\"title\">{this.labels.title}</div>\r\n                <div className=\"title2\">{this.labels.title2}</div>\r\n                <div className=\"subtitle\">{this.labels.subtitleOwner}</div>\r\n                <div className=\"subtitle\">Minted Tokens: {this.state.mochaTotalSupply}</div>\r\n                <div className=\"input-container ic1\">\r\n                  <input id=\"allowAddress\"  type=\"radio\" placeholder=\" \" checked  name=\"isToWhitelist\" value=\"allow\" onChange={this.handleInputChange} />\r\n                  <label for=\"allowAddress\" className=\"radioLabel\">Allow Address</label>\r\n                </div>\r\n                <div className=\"input-container ic1\">\r\n                  <input id=\"revokeAddress\"  type=\"radio\" placeholder=\" \"  name=\"isToWhitelist\" value=\"revoke\" onChange={this.handleInputChange} />\r\n                  <label for=\"revokeAddress\" className=\"radioLabel\">Revoke Address</label>\r\n                </div>\r\n                <div className=\"input-container ic1\">\r\n                  <input id=\"firstname\" className=\"input\" type=\"text\" placeholder=\"\"  name=\"kycAddress\" value={this.state.kycAddress} onChange={this.handleInputChange} />\r\n                  <div className=\"cut\"></div>\r\n                  <label className=\"placeholder\">Address (0x123...)</label>\r\n                </div>\r\n                \r\n                <button type=\"button\" className=\"submit\" onClick={this.handleKycWhiteListing}>Update KYC Whitelist</button>\r\n              </div>\r\n               \r\n              <div className=\"warning\" id=\"infoMessage\"></div>\r\n              <div className=\"plaintext\" id=\"transactionHash\">transactionHash</div>\r\n              <div className=\"plaintext\" id=\"receipt\">Receipt</div>\r\n              <div className=\"plaintext\" id=\"confirmation\">Confirmations</div>\r\n              <div className=\"warning\" id=\"error\"></div>\r\n              \r\n            </div>\r\n          </div>\r\n        );\r\n      } else {\r\n        if(this.state.whitelisted){\r\n            return (\r\n              <div>\r\n                <div  className=\"plaintext\">connected account: {this.accounts[0]}  --- ETH: {this.state.ethAccountAmmount} / MOCHA: {this.state.mochaAccountAmmount} </div>\r\n                <div className=\"container\"> \r\n                  <div className=\"form2\">\r\n                    <div className=\"title\">{this.labels.title}</div>\r\n                    <div className=\"title2\">{this.labels.title2}</div>\r\n                    <div className=\"subtitle\">{this.labels.subtitleWhitelisted}</div>\r\n                    <div className=\"subtitle\">Minted Tokens: {this.state.mochaTotalSupply}</div>\r\n               \r\n                    <div className=\"input-container ic1\">\r\n                      <input id=\"firstname\" className=\"input\" type=\"text\" placeholder=\"\" name=\"ethAmountToBuyToken\" value={this.state.ethAmountToBuyToken} onChange={this.handleInputChange} />\r\n                      <div className=\"cut\"></div>\r\n                      <label className=\"placeholder\">ETH amount in wei</label>\r\n                    </div>                    \r\n                    <p>\r\n                      <button type=\"button\"  className=\"submit\" onClick={this.handleBuyToken}> Buy MOCHA Token</button>\r\n                      <button type=\"button\"  id=\"addToken\"  className=\"submit\" onClick={this.addTokenToMetamask}> Add MOCHA Token to metamask wallet</button>\r\n                    </p>                    \r\n                  </div>  \r\n                  <div className=\"warning\" id=\"infoMessage\"></div>\r\n                  <div className=\"plaintext\" id=\"transactionHash\">transactionHash</div>\r\n                  <div className=\"plaintext\" id=\"receipt\">Receipt</div>\r\n                  <div className=\"plaintext\" id=\"confirmation\">Confirmations</div>\r\n                  <div className=\"warning\" id=\"error\"></div>\r\n                </div>     \r\n              </div>\r\n            );\r\n        } else {\r\n          return (\r\n            <div>\r\n              <div  className=\"plaintext\">connected account: {this.accounts[0]}  --- ETH: {this.state.ethAccountAmmount} / MOCHA: {this.state.mochaAccountAmmount} </div>\r\n              <div className=\"container\"> \r\n                <div className=\"form2\">\r\n                <div className=\"title\">{this.labels.title}</div>\r\n                  <div className=\"title2\">{this.labels.title2}</div>\r\n                  <div className=\"subtitle\">{this.labels.subtitleNotWhitelisted}</div>\r\n                  <div className=\"title2\">To test this Dapp you should add the account used to deploy the Smart Contracts on your metamask, that is the PK: </div>\r\n                  <div className=\"subtitle\">{this.labels.PK}</div>\r\n                  <div className=\"disclaimer\">Disclaimer: this is an account with test and development purposes, never share your Private Keys!</div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          );\r\n        }\r\n      }\r\n    }\r\n    \r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}